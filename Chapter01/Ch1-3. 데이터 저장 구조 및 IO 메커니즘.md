# 1. I/O
- SQL의 속도 저하 원인의 대부분은 <u>디스크 I/O</u>
- 평균 속도
	- Single Block I/O 기준 평균 10ms (초당 100 블록)
    - SAN 스토리지는 평균 4~8ms 정도 (초당 125~250 블록)
    - SSD 활용 스토리지는 평균 1~2ms 정도 (초당 500~1000 블록)
- 전반적으로 I/O 튜닝이 안 된 시스템이라면,
	- 동시다발적으로 I/O Call 발생
    - 디스크 경합이 심해짐
    - 대기 시간도 늘어남 
# 2. 데이터베이스 저장 구조
<div align="center">
<img src="https://velog.velcdn.com/images/hoonki/post/6f9b4616-441d-4212-9469-e3c20d84e237/image.png" width="600">
</div>

**데이터 파일**
	- 디스크 상의 물리적인 OS 파일

**테이블스페이스** 
	- 세그먼트를 담는 콘테이너
    - 여러 개의 데이터파일로 구성 
    	: 파일 경합을 줄이기 위해 가능한 한 여러 데이터파일로 분산 저장 

**세그먼트**
	- 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트
    - 테이블, 인덱스를 생성할 때 어떤 테이블스페이스에 저장할지를 지정
    - 여러 익스텐트로 구성
    - 테이블/인덱스가 파티션 구조라면, 각 파티션이 하나의 세그먼트 
    - LOB 컬럼은 그 자체가 하나의 세그먼트를 구성 

**익스텐트**
	- 공간을 확장하는 단위
    - 공간이 부족해지면, 해당 오브젝트가 속한 테이블스페이스로부터 익스텐트 추가 할당 
    - 연속된 블록들의 집합 
    - 익스텐트 내 블록은 연속되는 공간이지만, 익스텐트끼리는 연속된 공간이 아님
    - 한 익스텐트에 담긴 블록은 모두 같은 테이블 블록 
    
**블록**
	- 데이터를 읽고 쓰는 단위
    : 특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽음 
    - 블록 사이즈 확인
```sql
SQL > show parameter block_size
SQL > select value from v$parameter where name='db_block_size'
```    

`DBA` 
- Data Block Address
- 데이터 블록이 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타내는 고유 주소값
- 인덱스를 통해 데이터를 읽는 경우 <u>ROWID</u>를 이용
	- ROWID = DBA + 로우 번호 
- 테이블 스캔 시에는 테이블 세그먼트 헤더에 저장된 <u>익스텐트 맵</u> 이용
	- 익스텐트 맵을 이용해 각 익스텐트의 첫 번째 블록 DBA를 알 수 있음 
    
# 3. 액세스
## 시퀀셜 액세스
- 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식
- 인덱스 리프 블록
	- 앞뒤를 가리키는 주소값을 통해 논리적으로 연결되어 있음
    - 주소 값에 따라 앞 또는 뒤로 순차적으로 스캔
- 테이블 블록
	- 블록 간에는 논리적인 연결고리를 갖고 있지 않음
    - 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵으로 관리
    - <u>익스텐트 맵</u>은 각 익스텐트의 첫 번째 블록 주소 값을 가짐 
    - 읽어야 할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫 번쨰 블록 뒤에 연속해서 저장된 블록을 순서대로 읽음 
## 랜덤 액세스
- 논리적, 물리적인 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식 

# 4. 버퍼 캐시
> 디스크에서 읽어온 데이터 블록을 캐싱 

- SGA의 구성 요소 중 하나
- 데이터 블록을 읽어야 할 땐, 항상 버퍼 캐시를 먼저 경유 
	(Direct Path I/O 제외) 
	- 인덱스 루트 블록을 읽을 때
    - 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
    - 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
    - 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
    - 테이블 블록을 Full Scan할 때
    
## 논리적/물리적 I/O
- 논리적 I/O
	- SQL을 처리하는 과정에 발생한 총 블록 I/O
	- Direct Path Read를 제외하면, 버퍼 캐시를 모두 경유하므로 메모리 I/O가 곧 논리적 I/O
    - 데이터를 입력/수정/삭제하지 않고 조건절의 변수도 동일하다면 여러 번 실행하더라도 일정함
- 물리적 I/O
	- 디스크에서 발생한 총 블록 I/O
	- 버퍼 캐시에서 블록을 찾지 못한 경우 발생
    - 즉, 논리적 I/O 중 일부를 물리적으로 I/O
    - 디스크를 접근하므로 속도가 느림 
    - SQL의 실행 조건 등에 따라 매번 달라짐 

## 버퍼캐시 히트
- 찾고자 하는 데이터가 버퍼 캐시에 존재하는 경우 **버퍼캐시 히트** 라고 함
- 버퍼캐시 히트율(BCHR, Buffer Cache Hit Ratio)
	: 읽은 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율 
```
BCHR = (캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수 ) x 100
     = ( (논리적 I/O - 물리적 I/O) / 논리적 I/O) x 100
     = (1 - (물리적 I/O) / (논리적 I/O) ) x 100
```
- 온라인 트랜잭션을 처리하는 애플리케이션이라면 평균 99% 히트율 달성 필요 
- 데이터를 캐시에서 찾지 못하면, 디스크에서 버퍼캐시로 적재하고서 읽음 

## 성능 향상
```
물리적 I/O = 논리적 I/O x (100% - BCHR)
```
- 논리적 I/O는 항상 일정하므로, 물리적 I/O는 BCHR에 의해 결정
	- BCHR은 시스템 상황에 따라 달라짐
    - 즉, 물리적 I/O는 시스템 상황에 의해 결정되는 통제 불가능한 외생변수 

=> SQL 성능을 높이기 위해서는 **논리적 I/O를 줄여야 함**
   즉, 논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 SQL 튜닝 

## 버퍼캐시 구조
- 해시 알고리즘으로 버퍼 헤더를 찾고, 얻은 포인터로 버퍼 블록을 액세스
- 해시 구조
	- 같은 입력 값은 항상 동일한 해시 체인에 연결됨
    - 다른 입력 값이 동일한 해시 체인에 연결될 수 있음
    - 해시 체인 내에서는 정렬이 보장되지 않음
## 래치
- 버퍼캐시는 SGA 구성요소 이므로, 하나의 블록을 두 개 이상의 프로세스가 동시에 접근할 수 있음
- 동시에 접근하면 블록 정합성에 문제가 생길 수 있으므로 <u>직렬화</u> 메커니즘이 필요 
- 버퍼캐시에는 캐시버퍼 체인 래치, 캐시버퍼 LRU 체인 래치 등이 존재 
- 버퍼블록 자체에도 <u>버퍼 Lock</u> 이라는 직렬화 메커니즘 존재
	- 읽고자 하는 블록을 찾았으면 캐시버퍼 체인 래치가 해제됨
    - 래치를 해제한 상태에서 다른 프로세스가 같은 블록에 접근한다면 정합성에 문제가 생길 수 있음
    - 캐시버퍼 체인 래치를 해제하기 전에 버퍼 헤더에 Lock을 설정하여 버퍼블록 자체에 대한 직렬화 문제 해결 
# 5. Single/Multi block I/O
- Single Block I/O : 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식
- Multiblock I/O : 한 번에 여러 블록씩 요청해서 메모리에 적재하는 방식 
<hr>
- 기본적으로는 인덱스와 테이블 블록 모두 Single Block I/O 방식 사용 
- 많은 데이터 블록을 읽을 때는 Multiblock I/O 방식이 효율적 
	- Mutliblock I/O 단위가 크면 성능이 좋아짐 
    - 인접한 블록만 가능하므로, 같은 익스텐트에 속한 블록만 가능 
```
SQL> show parameter db_file_multiblock_read_count
SQL> alter session set db_file_multiblock_read_count=128;
```
cf ) Multiblock I/O 중간에 나타나는 Singe Block I/O
- 익스텐트 맵을 통해 읽어야 할 블록 목록을 확인하고 순서대로 읽어나감
- 블록이 캐시에 없는 경우 바로 I/O하지 않고 보류했다가, Multiblock I/O 단위가 채워지면 수행하는 것이 기본
- Multiblock I/O 단위가 채워지지 않았는데, 캐시에 존재하는 블록을 만난 경우 바로 I/O 수행
	- 1개 block이면 Single Block I/O 방식
    - 2개 이상 block이면 Multiblock I/O 방식 
- Full Scan 중에 Chain이 발생한 로우를 읽을 때도 Single Block I/O 방식으로 읽음
<hr>
- Table Full Scan은 <u>시퀀셜 액세스</u> 와 <u>Multiblock I/O</u>로 읽음
- Index Scan은 <u>랜덤 액세스</u>와 <u>Single Block I/O</u>로 읽음 


**Reference**
[데이터베이스 저장 구조 이미지](https://velog.io/@hoonki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%80%EC%9E%A5-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%95%A1%EC%84%B8%EC%8A%A4-%EB%B0%A9%EB%B2%95)