# 1. 기본 메커니즘
1. Build 단계 : 작은 쪽 테이블(=Build Input)을 읽어 해시 테이블을 생성
2. Probe 단계 : 큰 쪽 테이블(=Probe Input)을 읽어 해시 테이블을 탐색하면서 조인 

# 2. Hash Join
## 실행 계획
```sql
Execution Plan
--------------------------------------------------------
0		SELECT STATEMENT Optimizer = ALL_ROWS
1	0	 HASH JOIN
2	1	  TABLE ACCESS (BY INDEX ROWID) OF '사원' (TABLE)
3	2	   INDEX (RANGE SCAN) OF '사원_X1' (INDEX)
4	1	  TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE)
5	4	   INDEX (RANGE SCAN) OF '고객_N1' (INDEX)
```
- 위쪽 테이블로 해시 테이블을 생성
- 아래쪽 테이블에서 읽은 조인 키 값으로 해시 테이블을 탐색하면서 조인 
- 현재는 Build Input과 Probe Input을 읽을 때 인덱스를 이용했지만, Table Full Scan으로도 처리 가능 

## 제어
- `use_hash` 힌트로 유도 가능
```sql
select /*+ ordered use_hash(c) */
		e.사원번호,e.사원명, e.입사일자
        ,c.고객번호,c.고객명,c.전화번호,c.최종주문금액
from 사원 e,고객 c
where c.관리사원번호 = e.사원번호
and e.입사일자 >= '19960101'
and e.부서코드 = 'Z123'
and c.최종주문금액 >= 20000
```
- 일반적으로 옵티마이저는 카티널리티가 작은 테이블을 build input으로 선택
- 직접 선택하고 싶다면 `leading` 이나 `ordered` 힌트를 사용하거나 `swap_join_inputs`,`no_swap_join_inputs` 으로 명시적 선택 가능
	- 기본적으로 가장 먼저 읽는 테이블을 build input으로 수행
    - `no_swap_join_inputs` 으로 build input으로 선택하고 싶은 테이블이 조인된 결과 집합인 경우에 반대인 probe input을 지정 가능
    
```sql
 select /*+ leading(e) use_hash(c) swap_join_inputs(c) */
 		e.사원번호, e.사원명, e.입사일자
        ,c.고객번호 , c.고객명, c.전화번호, c.최종주문금액
 from 사원 e, 고객 c
 where c.관리사원번호 = e.사원번호
 and e.입사일자 >='19960101'
 and e.부서코드 = 'Z123'
 and c.최종주문금액>=20000
```

## 수행 예시
1. 아래 조건에 해당하는 사원 데이터를 읽어 조인컬럼을 키 값으로 하는 해시테이블을 생성. 
```sql
select 사원번호,사원명,입사일자
from 사원
where 입사일자>='19960101'
and 부서코드='Z123'
```
 - 해시 테이블은 PGA 영역에 할당된 hash area에 저장
 - 해시 테이블이 너무 큰 경우 Temp 테이블스페이스에 저장

2. 아래 조건에 해당하는 고객 데이터를 하나씩 읽으면서 해시 테이블을 탐색. 
```sql
select 고객번호,고객명,전화번호,최종주문금액,관리사원번호
from 고객
where 최종주문금액 >= 20000
```
- 조인컬럼을 입력해서 반환된 값으로 해시 체인을 찾은 뒤,
- 해시 체인을 스캔해서 조인컬럼이 같은 값을 찾으면 조인 성공, 못 찾으면 조인 실패
- 조인 과정
```sql
begin
	for outer in (select 고객번호, 고객명, 전화번호, 최종주문금액, 관리사원번호
    				from 고객
                    where 최종주문금액 >= 20000)
    loop
    	for inner in (select 사원번호,사원명,입사일자
        				from PGA에 생성한 사원 해시맵
                        where 사원번호=outer.관리사원번호)
         loop
         	dbms_output.put_line(....);
         end loop;
    end loop;
end
```
- probe 단계는 NL 조인과 비슷하게 조인 오퍼레이션이 수행됨

## 특징
- <u>PGA 사용</u>
	- 해시 테이블을 PGA 영역에 할당
    - 래치 획득 과정 없이 빠르게 데이터를 탐새갛고 조인 가능 
- <u>해시 테이블</u>
	- 해시 테이블에 조인 키 값만 있다면 추가적인 테이블 액세스가 필요
    - 따라서, SQL에 사용한 컬럼을 해시 테이블에 모두 저장 
- <u>간단한 사전 준비 과정</u>
	- 소트 머지 조인은 양쪽 집합을 정렬해야 하므로, 두 집합 중 하나가 중대형 이상이면 temp 테이블 스페이스에 쓰는 작업이 필수적
    - 해시 조인은 둘 중 작은 집합으로 해시 테이블을 만들기 때문에 두 집합 모두 큰 경우가 아니라면 디스크 쓰기 작업을 일어나지 않음 

# 3. 대용량 Build Input
- 조인 대상 집합이 모두 대용량이어서 인메모리 해시 조인이 불가능한 경우도 존재
- 이 경우 **분할&정복** 방식으로 진행
## Divide & Conquer
1. 파티션 단계
- 조인하는 양쪽 집합의 조인 컬럼에 해시 함수를 적용
- 반환된 해시 값에 따라 동적으로 파티셔닝 
- 독립적으로 처리할 수 있는 여러 개의 작은 서브 집합으로 분할함으로써 파티션 짝을 생성
- 즉, 양쪽 집합을 읽어 디스크 Temp 공간에 저장해야 하므로 성능이 많이 떨어짐

2. 조인 단계
- 각 파티션 짝에 대해 하나씩 조인을 수행
- Build Input과 Probe Input은 독립적으로 결정
	- 파티션 짝 별로 작은 쪽을 build input으로 선택해서 해시 테이블 생성
- 해시 테이블을 생성 후에는 반대쪽 파티션 로우를 하나씩 읽으면서 해시 테이블을 탐색
- 모든 파티션 짝에 대한 처리를 마칠 때까지 이 과정을 반복

# 4. 조인 메소드 선택 기준
## 일반적인 선택 기준 
1. 소량 데이터 조인일 때 **NL 조인**
2. 대량 데이터 조인일 때 **해시 조인**
3. 대량 데이터 조인인데, 조인 조건식이 등치 조건이 아닐 때 **소트 머지 조인**

** 대량 데이터 조인 : NL조인 기준으로 최적화했는데도 랜덤 액세스가 많은 경우 

## 수행빈도가 매우 높은 쿼리
1. 최적화된 NL 조인과 해시 조인 성능이 같으면 **NL 조인**
2. 해시 조인이 약간 더 빠르더라도 **NL 조인**
3. NL 조인보다 해시 조인이 매우 빠른 경우 **해시 조인**

즉, 수행 빈도가 높은 소량 데이터 조인은 해시 조인이 약간 더 빠르더라도 NL 조인을 선택하는 것이 좋음
- 해시 테이블은 하나의 쿼리를 위해 생성하고, 조인이 끝나면 곧바로 소멸
- NL 조인에 사용하는 인덱스는 영구적으로 유지하면서 다양한 쿼리에 공유 및 재사용 가능 
- 따라서, 수행시간이 짧으면서 수행빈도가 매우 높은 쿼리를 해시 조인으로 처리하면 CPU와 메모리 사용률이 크게 증가하고 해시 맵을 만드는 과정에서 여러 래치 경합도 발생 

**OLTP 환경에서 해시 조인을 사용하는 조건**
1. 수행 빈도가 낮고
2. 쿼리 수행 시간이 오래 걸리는
3. 대량 데이터 조인일 때 