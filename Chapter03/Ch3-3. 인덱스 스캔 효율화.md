# 1. 인덱스 스캔
> 인덱스 선행 컬럼이 조건절에 없거나 '=' 조건이 아니면 인덱스 스캔 과정에 비효율이 발생 

## 효율성 측정 
- SQL 트레이스 확인
```
Rows	Row Source Operation
------	----------------------------------------------------------------
	10	TABLE ACCESS BY INDEX ROWID BIG_TABLE (cr=7471 pr=1466 pw=0 time=22137 us)
    10	 INDEX RANGE SCAN BIG_TABLE_IDX (cr=7463 pr=1466 pw=0 time=22328 us)
```

- 인덱스 스캔으로 얻은 레코드 10개
- 그 과정에서 7,463개의 블록을 읽음 
- 한 블록당 평균 500개 레코드가 담긴다고 가정하면, 7,463x500=3,731,500개의 레코드 중 10개를 얻었다는 의미 

## 액세스/필터 조건
<div align="center">
<img src="https://velog.velcdn.com/images/dasd412/post/ab251bfa-af58-4133-bb6c-769a2ff63152/image.PNG" width="650">
</div>

1. 인덱스 액세스 조건
	- 인덱스 스캔 범위를 결정하는 조건절
    - 인덱스의 수직적 탐색을 통해 스캔 시작점을 결정하는데 영향을 미치고, 인덱스 리프 블록의 스캔을 어디서 멈출지를 결정
2. 인덱스 필터 조건
	- 테이블로 액세스할지를 결정하는 조건절 
3. 테이블 필터 조건
	- 테이블 액세스 단계에서 처리되는 조건절은 모두 필터 조건
    - 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정 

<hr>

- 선행 컬럼이 모두 `=` 조건인 상태에서,
	- 첫 번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여 있음
    - 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어짐 
- 즉, 첫 번째 나타나는 범위검색 조건절까지가 인덱스 스캔 범위를 결정하는 **인덱스 액세스 조건**
- 아래의 케이스를 제외하면, 인덱스 컬럼에 대한 조건절은 모두 액세스 조건
	- 좌변 컬럼을 가공한 조건절
    - 왼쪽 `%` 또는 양쪽 `%` 기호를 사용한 like 조건절
    - 같은 컬럼에 대한 조건절이 두 개 이상일 때, 인덱스 액세스 조건으로 선택되지 못한 조건절
    - OR Expansion 또는 INLIST ITERATOR로 선택되지 못한 OR 또는 IN 조건절 

# 2. 비효율적인 인덱스 스캔
## ① 인덱스 선행 컬럼이 등치 조건이 아닐 때 
- 인덱스 선행컬럼이 조건절에 없거나, 부등호/BETWEEN/LIKE 등의 범위검색 조건이면 비효율이 발생 
- 인덱스 선행컬림이 `=` 조건이면, 필요한 범위만 스캔하고 멈출 수 있음
	- 조건을 만족하는 레코드가 모두 모여 있기 때문 
### BETWEEN을 IN-List 로
- 인덱스 구성을 바꾸기가 쉽지 않다면, BWTWEEN 조건을 IN-List로 바꿔주면 큰 효과를 얻을 수 있음 
- IN-List 의 개수만큼 인덱스의 수직적 탐색이 일어남
- 즉, IN-List 각각의 값을 `=` 조건으로 검색 후 UNION ALL 한 형태
- IN-List 항목이 늘어날 수 있다면 <u>NL 방식의 조인문</u> 이나 <u>서브쿼리</u> 로 구현 가능 

```sql
------------------------------------------------------------------------
|Id|Operation						|Name		|Rows	|Bytes	|Cost|
|0 |SELECT STATEMENT				|			|		|		|	6|
|1 | INLIST ITERATOR				|			|		|		|	 |
|2 |  TABLE ACCESS BY INDEX ROWID 	|			|	   3|	  37|	6|
|3 |   INDEX RANGE SCAN             |			|	   3|       |   5|
```

**주의사항**
- IN-List 개수가 많은 경우
	- 수직적 탐색이 많이 발생
    - BETWEEN 조건으로 리프 블록을 스캔하는 비효율보다 IN-List 개수만큼의 브랜치 반복 탐색 비효율이 커질 수 있음
    - 루트에서 브랜치 블록까지의 depth가 깊은 경우 비효율이 심해짐
- 인덱스 스캔 과정에 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용함
	- 레코드가 가까이 있다는 것은, 각 레코드 사이 인덱스 블록이 매우 소량이라는 뜻
    - 이런 경우 효과가 전혀 없거나 수직적 탐색으로 인한 블록 I/O가 더 많이 발생할 수 있음
- `IN` != `=`
	- `IN` 이 `=` 이 되려면, IN-List Iterator 방식으로 풀려야 함
    - 그렇지 않으면 IN은 필터 조건으로 적용됨
    - 단, 액세스 조건으로 변경하는게 무조건적인 성능 향상을 가지고 오는지는 고민 필요 
    
**NUM_INDEX_KEYS**
- IN-List를 액세스 조건 또는 필터 조건으로 유도하는 방법
- num_index_keys(테이블명 인덱스명 기준컬럼순서)
	- 기준컬럼순서=1 인 경우, 인덱스 첫 번째 컬럼까지만 액세스 조건으로 사용하라는 의미 
- 힌트를 사용하지 않고 인덱스 컬럼을 가공하기도 함 

### Index Skip Scan 활용 
- 조건절을 바꾸지 않아도 동일한 효과를 낼 수 있음
- 오히려 IN-List 보다 더 나은 효과를 보이기도 함 

## ② LIKE를 무분별하게 사용할 때
```sql
SELECT * FROM 월별고객별판매집계
WHERE 판매월 LIKE '2019%';
```
```sql
SELECT * FROM 월별고객별판매집계
WHERE 판매월 BETWEEN '201901' AND '201912';
```

- `LIKE` 와 `BETWEEN` 모두 범위조건 검색이나, 데이터 분포와 조건절 값에 따라 인덱스 스캔량이 서로 다를 수 있음 
- `LIKE` 보다 `BETWEEN` 을 사용하는 것이 더 좋음
	- 큰 차이가 아니더라도 `BETWEEN` 을 사용하면 적어도 손해는 보지 않는다. 
- `LIKE` 는 '201900' , '201913' 등의 값이 존재하는 경우를 위해 불필요한 데이터를 읽게 됨
	- 이에 반해 `BETWEEN` 은 스캔 중단점이 명확함
    
## ③ 다양한 옵션 처리 
- 선택 옵션이 있는 경우 하나의 SQL문으로 처리하기 위해 비효율이 발생하기도 함
### (1) OR 조건 활용
```sql
SELECT * FROM 거래
WHERE (:cust_id is null or 고객ID = :cust_id)
AND 거래일자 between :dt1 AND :dt2
```

**장점**
- 옵션 조건 컬럼이 NULL 허용 컬럼이더라도 결과집합을 보장 

**단점**
- 위의 쿼리에서 옵션 조건 컬럼인 cust_id를 선두로 인덱스를 구성하더라도 사용할 수 없음 
- [거래일자+고객ID] 의 인덱스를 사용하면, cust_id를 테이블 액세스 단계에서 필터링되어 비효율적
	- 거래일자를 만족하는 레코드 모두를 테이블 랜덤 엑세스한 후 고객ID를 필터링 
    - 즉, 인덱스 액세스 조건과 인덱스 필터 조건 모두 사용 불가능
- 참고로, 인덱스에 포함되지 않은 컬럼에 대한 옵션 조건은 OR 조건을 사용해도 무방
	- 어차피 테이블에서 필터링 해야하기 때문 

**참고**
- 18c부터, 인덱스 구성 컬럼 중 하나 이상이 Not NULL 컬럼이면 인덱스 필터 조건으로 사용 가능 

### (2) LIKE/BETWEEN 조건 활용
```sql
SELECT * FROM 상품
WHERE 등록일시>= trunc(sysdate)
AND 상품분류코드 like :prd_cls_cd || '%'
```
**장점**
- 변별력이 좋은 필수 조건이 있는 상황이라면 성능이 나쁘지 않음
	- 필수 조건 컬럼을 인덱스 선두에 두고 액세스 조건으로 사용
 	- 필수 조건이 `=` 인 경우 옵션 조건까지도 인덱스 액세스 조건이므로 최적의 성능 가능 

**단점**
- 필수 조건의 변별력이 좋지 않은 경우 성능을 보장할 수 없음
	- Table Full Scan이 유리한 상황에도, 옵션 조건까지 입력했을 때를 기준으로 Index Ragne Scan이 선택될 수 있음 
 
**점검사항**
1. 인덱스 선두 컬럼
- 인덱스 선두 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 처리 불가 

2. NULL 허용 컬럼
- NULL 허용 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 처리 불가 
- 이 경우에는, 성능을 떠나 결과 집합에 오류가 생김 
- NULL 값인 데이터가 결과 집합에서 누락되기 때문 

3. 숫자형 컬럼
- 숫자형이면서 인덱스 액세스 조건으로 사용 가능한 컬럼에 대해서 LIKE 처리 불가
- 자동 형 변환이 발생하기 때문 

4. 가변 길이 컬럼 
- LIKE를 옵션 조건에 사용할 때는 컬럼 값 길이가 고정적이어야 함 
	- 'AA' 를 입력했을 때 'AAB'도 같이 조회되기 때문 
- 컬럼 값 길이가 가변적인 경우 변수 값 길이가 같은 레코드만 조회되도록 조건절 추가
```sql
WHERE 고객명 LIKE :cust_nm || '%'
AND length(고객명) = length(nvl(:cust_nm,고객명))
```

### (3) UNION ALL 활용
```sql
SELECT * FROM 거래
WHERE :cust_id IS NULL
AND 거래일자 BETWEEN :dt1 AND :dt2
UNION ALL
SELECT * FROM 거래
WHERE :cust_id IS NOT NULL
AND 거래일자 BETWEEN :dt1 AND :dt2
```
- 옵션 조건의 값에 따라 사용하는 인덱스가 달라질 수 있음
- 옵션 조건 컬럼도 인덱스 액세스 조건으로 사용 가능하며, NULL 허용 컬럼이더라도 문제가 발생하지 않음 
- 즉, 옵션 조건에 상관없이 가장 최적의 인덱스 사용

### (4) NVL/DECODE 함수 활용
```sql
SELECT * FROM 거래
WHERE 고객ID = nvl(:cust_id,고객ID)
AND 거래일자 BETWEEN :dt1 AND :dt2

SELECT * FROM 거래
WHERE 고객ID = decode(:cust_id,null,고객ID,:cust_id)
AND 거래일자 BETWEEN :dt1 AND :dt2
```
**장점**
- OR Expansion 쿼리 변환 가능
- 옵션 조건 컬럼을 인덱스 액세스 조건으로 사용 가능 

**단점**
- NULL 허용 컬럼에 사용할 수 없음 
	- 조건절 변수에 NULL을 입력하면 NULL인 레코드가 결과집합에서 누락 

**주의**
- NVL/DECODE 함수를 여러 개 사용하면 변별력이 가장 좋은 컬럼 기준으로 한 번만 OR Expansion이 일어남 

# 3. PL/SQL
- PL/SQL로 작성한 함수 및 프로시저 컴파일
	- 바이트코드 생성
    - 데이터 딕셔너리에 저장
    - PL/SQL 엔진으로 실행 : 바이트 코드를 런타임 시 해석하면서 실행 
- PL/SQL 사용자 정의 함수는 속도가 느림
	- 가상머신 상에서 실행되는 인터프리터 언어
    - 호출 시마다 컨텍스트 스위칭 발생
    - 내장 SQL에 대한 Recursive Call 발생 
- PL/SQL 함수를 실행하면 SQL 실행 엔진과 PL/SQL 가상머신 사이에 컨텍스트 스위칭이 발생 
## 함수호출 최소화
```sql
SELECT 회원번호, 회원명, 생년, 생원일, GET_ADDR(우편번호) AS 기본주소
FROM 회원
WHERE 생원일 LIKE '01%'
```
- 위의 쿼리에서 GET_ADDR() 은 조건을 만족하는 회원 수만큼 실행됨
- 함수에 SQL이 내장되어 있는 경우 그 SQL도 조건을 만족하는 회원 수만큼 실행됨 
- PL/SQL에는 보통 SQL이 내장되어 있으므로 Recursive Call의 부하가 심함
	- 가능한 PL/SQL을 사용하지 않고 조인문 등으로 처리하면 성능 차이가 큼
    - 하지만, 내부 로직이 복잡해서 그대로 사용해야 하는 경우 함수 호출 횟수를 줄이는 방법 중 하나가 **액세스 조건을 고려한 인덱스 구성**

**Reference**
- [액세스/필터조건 이미지](https://velog.io/@dasd412/%EC%B9%9C%EC%A0%88%ED%95%9C-SQL-%ED%8A%9C%EB%8B%9D)