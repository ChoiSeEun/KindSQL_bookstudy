# 1. 인덱스가 많으면 발생하는 문제
- DML 성능 저하로 인한 TPS 저하
	- 신규 데이터가 입력될 때마다 모든 인덱스에 데이터를 입력해야 함
	- 인덱스는 정렬을 유지하고 있으므로, 신규 입력을 위해선 수직적 탐색/인덱스 분할 필요
	- 데이터를 삭제하는 경우에도 동일하게 모든 인덱스에서 데이터를 삭제해야 함 
- 데이터베이스의 사이즈가 증가하여 디스크 공간 낭비
- 데이터베이스 관리 및 운영 비용 상승 

# 2. 선택 기준
**인덱스 스캔 효율성 판단** 
- 조건절에 항상 사용하거나 자주 사용하는 컬럼을 인덱스 선두 컬럼으로 사용
- `=` 조건으로 자주 조회하는 컬럼을 앞 쪽에 두어 결합 인덱스를 구성 

**그 외**
- 수행 빈도
- 업무상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하 : 기존 인덱스 개수, 초당 DML 발생량, 자주 갱신하는 컬럼 포함 여부 등
- 저장 공간
- 인덱스 관리 비용 등 

# 3. 소트 연산 생략
- 인덱스는 정렬 상태를 유지하므로, 소트 연산을 생략할 수 있는 경우가 존재
- 조건절에 사용되지 않더라도, 소트 연산을 생략할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선 도모 가능 
## 인덱스 구성 방법
### 성능을 고려하지 않는다면 
- OREDER BY 절 순서대로 구성
- `=` 조건절 컬럼은 ORDER BY 절에 없어도 인덱스 구성에 포함 가능
	- `=` 조건절 컬럼의 위치는 무관
- `=` 이 아닌 조건절 컬럼들은 ORDER BY 컬럼보다 뒤에 있어야 소트 연산 생략 가능 
### 성능을 고려한다면
= I/O를 최소화하면서도 소트 연산을 생략

- `=` 연산자로 사용한 조건절 컬럼 선정
- ORDER BY 절에 기술한 컬럼 추가
- `=` 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정 
	- 조건을 만족하는 데이터가 많지 않으면 인덱스에 추가하여 테이블 랜덤 액세스를 줄이고,
    - 조건을 만족하는 데이터가 많으면 굳이 인덱스에 추가할 필요가 없음
### 주의 사항
- IN 조건절을 인덱스 액세스 조건으로 사용하면 안됨
	- 즉, IN 조건절이 IN-List Iterator 방식으로 풀리면 안됨
    - UNION ALL의 대상 집합이 정렬이 보장되지 않기 때문 
    - 따라서 IN 조건절은 필터 조건으로 사용되어야 소트 연산 생략이 가능

# 4. 선택도 고려
> 선택도 : 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율

> 인덱스 선택도 : 인덱스 컬럼을 모두 `=` 로 조회할 때 평균적으로 선택되는 비율

- 선택도가 높은 인덱스는 테이블 액세스가 많이 발생하므로 효용가치가 별로 없음 
- 단, 결합 인덱스 구성 시 선택도가 낮은 컬럼을 앞에 두는 것이 무조건 유리하다는 의미는 아님
	- 인덱스 컬럼이 필수 `=` 조건이라면 컬럼 순서에 따라 인덱스 스캔 효율이 차이나지 않음 
    - 어떤 컬럼이 앞으로 오든 인덱스 스캔의 범위는 동일
   	- 옵션 조건이거나 범위검색 조건 등의 경우는 유리한 경우가 있을 수 있음
- 다시 말해 인덱스 생성 여부를 결정할 때는 선택도가 매우 중요하지만,
- 컬럼 간 순서는 선택도 보다 필수 조건 여부, 연산자 형태가 더 중요한 판단 기준임 

# 5. 중복 인덱스 
- 완전 중복 : IDX2의 선두 컬럼이 IDX1의 인덱스 전체를 포함하는 경우 
- 불완전 중복 : 선두 컬럼만 동일하고 두 번째 컬럼은 모두 다르지만, 선두 컬럼의 카디널리티가 매우 낮아 사실상 중복인 경우 

  
