# 1. 인덱스 튜닝
- **[인덱스 스캔 효율화 튜닝]** 인덱스 스캔 과정에서 발생하는 비효율을 줄이기
	- 인덱스 정렬 컬럼에 따라 스캔해야 할 데이터의 양이 달라짐 
- **[랜덤 액세스 최소화 튜닝]** 테이블 액세스 횟수를 줄이기
	- 인덱스 스캔 후 테이블 레코드를 액세스할 때 발생하는 랜덤 I/O를 줄여야 함
    - 성능에 미치는 영향이 더 크므로, 인덱스 튜닝의 가장 주된 요소임
=> <u>SQL 튜닝은 랜덤 I/O와의 전쟁</u>

# 2. 인덱스 구조
- 인덱스 : 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트
- 인덱스를 이용하면 <u>범위 스캔</u>이 가능
- DBMS는 일반적으로, **B*Tree** 인덱스를 사용 
	- LMC(Leftmost Child) : 자식 노드 중 가장 왼쪽 끝에 위치한 블록
    - 리프 블록에 저장된 레코드는 키 값 순으로 정렬되어 있으며, ROWID를 가짐
    	- ROWID = 데이터 블록 주소 + 로우 번호 
        - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
        - 블록 번호 = 데이터파일 내에서 부여한 상대적 순번
        - 로우 번호 = 블록 내 순번 
> ① BTree
> - 하나의 노드에 여러 개의 데이터를 저장하는 방식으로 Tree의 height를 줄여 탐색 시간을 줄인 Balanced-Tree
> - 규칙
	- 노드 안에 k개의 데이터가 있다면 자식 노드 수는 k+1개여야 한다.
    - 노드 안 데이터는 정렬되어야 한다.
    - 자식 노드의 데이터는 부모 노드의 데이터에 따라 배치된다. 
    - 루프 노드가 리프 노드가 아닌 경우 항상 2개 이상의 자식을 갖는다.
    - M차 B-tree라면 루트 노드와 리프 노드를 제외하고 최소 M/2개 이상의 데이터를 가지고 있어야 한다.
    - 모든 리프 노드의 높이는 같아야 한다.
    - 리프 노드의 데이터 수는 M보다 작아야 한다. 
> 
> ② B*Tree
> - 균형을 유지하기 위한 연산에서 노드의 생성과 부가적인 연산을 최소화하기 위해 등장
> - 차이점
>	- 자식 노드가 최소 M*2/3개의 데이터를 가짐
>	- 노드가 가득 찼을 때 분열하지 않고 형제 노드로 재배치
>
> ③ B+Tree
> - B-Tree의 확장 개념
> - 차이점
> 	- 중간 노드에는 key만 두고 value는 담지 않음
> 	- 리프 노드에만 key와 data를 저장하고, 리프 노드끼리 Linked List로 연결
> - 장점
>	- 메모리를 더 확보할 수 있음
> 	- 트리의 높이 또한 낮아지게 됨 
>	- 탐색 시 리프 노드의 데이터만 살피므로 B-Tree보다 탐색이 유리 

# 3. 인덱스 탐색
## ① 수직적 탐색
> 인덱스 스캔의 시작지점을 찾는 과정

- 정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정 
- 루트 블록에서부터 시작
- 루트를 포함한 브랜치 블록에 저장된 레코드는 하위 블록에 대한 주소값을 가짐
- 찾고자 하는 값보다 크거나 같은 값을 만나면, 바로 직전 레코드가 가리키는 하위 블록으로 이동
## ② 수평적 탐색
> 본격적으로 데이터를 찾는 과정

- 수직적 탐색으로 찾은 시작점에서부터, 찾고자 하는 데이터가 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔 
- 인덱스 리프 블록은 앞뒤 블록에 대한 주소값을 가지는 양방향 연결 리스트 구조


**Reference**
[B-Tree/B*Tree/B+Tree](https://yeongjaekong.tistory.com/38)