# 1. 오라클 Lock
- 공유 리소스와 사용자 데이터를 보호할 목적으로 다양한 종류의 Lock을 사용
	- **DML Lock**
    - DDL Lock
    - 래치 : SGA에 공유된 각종 자료구조를 보호하기 위해 사용 
    - 버퍼 Lock : 버퍼 블록에 대한 액세스를 직렬화하기 위해 사용 
    - 라이브러리 캐시 Lock/Pin : 라이브러리 캐시에 공유된 SQL 커서와 PL/SQL 프로그램을 보호하기 위해 사용 
    - 이 외 내부 Lock .. 

## DML Lock
- 애플리케이션 개발 측면에서 가장 중요하게 다루어야 할 Lock
- 다중 트랜잭션이 동시에 액세스하는 사용자 데이터의 무결성을 보호
### ① DML 로우 Lock
- 두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지
- 하나의 로우를 변경하려면 로우 Lock을 먼저 설정해야 함 
- <u>배타적 모드</u>를 사용
	- UPDATE/DELETE를 진행중인 로우를 다른 트랜잭션이 UPDATE하거나 DELETE할 수 없음 

**INSERT 로우 Lock 경합**
- unique 인덱스가 있을 때만 발생
- 두 트랜잭션이 같은 값을 입력하려고 하면 블로킹이 발생
	- 선행 트랜잭션이 커밋하면 후행 트랜잭션은 INSERT 실패
    - 선행 트랜잭션이 롤백하면 후행 트랜잭션은 INSERT 성공 
- 두 트랜잭션이 다른 값을 입력하거나, unique 인덱스가 없으면 로우 Lock 경합은 발생하지 않음 

**MVCC 모델**
- 오라클은 MVCC를 사용하기 때문에, SELECT 문에는 로우 Lock을 사용하지 않음
- 다른 트랜잭션이 변경한 로우를 읽으려면, 복사본 블록을 만들어서 쿼리가 시작된 시점으로 되돌려서 읽음
- 변경이 진행 중인 로우를 읽을 때도 Lock이 풀릴 때까지 기다리지 않고 복사본을 만들어서 읽음 
- 따라서 SELECT 문에 lock을 사용할 필요가 없음 
- 참고로, MVCC 모델을 사용하지 않는 DBMS는 SELECT문에 공유 lock을 사용
### ② DML 테이블 Lock
> 자신이 해당 테이블에서 현재 어떤 작업을 수행 중인지를 알리는 일종의 푯말

- 오라클은 DML 로우 Lock을 설정하기에 앞서 테이블 Lock을 먼저 설정
- 현재 트랜잭션이 갱신 중인 테이블 구조를 다른 트랜잭션이 변경하지 못하게 막기 위함 
- 테이블 Lock = TM Lock
- 테이블 Lock에는 여러가지 모드가 존재
	- RS : row share
    - RX : row exclusive
    - S : share
    - SRX : share row exclusive
    - X : exclusive
- 선행 트랜잭션과 호환되지 않는 모드로 테이블 Lock을 설정하려는 후행 트랜잭션은 대기하거나 작업을 포기해야 함 

**진로 선택**
- Lock을 얻고자 하는 리소스가 사용 중일때, 프로세스는 세 가지 방법 중 하나를 선택
	1. Lock이 해제될 때까지 기다림
    2. 일정 시간만 기다리다가 포기
    3. 기다리지 않고 작업을 포기 
- 대부분 내부적으로 진로가 결정되어 있지만, 사용자가 선택할 수 있는 경우도 존재
	- `SELECT FOR UPDATE` 문은 사용자가 3가지 옵션을 모두 선택 가능 
- DML 수행 시 묵시적으로 설정하는 테이블 Lock은 1번 옵션
- Lock Table 명령을 통해 명시적으로 테이블 Lock을 설정할 때는,
	- 기본적으로 1번 옵션
    - `NOWAIT` 옵션을 이용해 곧바로 작업 포기 가능 
    ```sql
    lock table emp in exclusive mode NOWAIT;
    ```
- DDL 수행 시 내부적으로 설정하는 테이블 Lock은 `NOWAIT` 옵션이 자동으로 지정 
- 11g부터 ddl_lock_timeout 파라미터를 0보다 크게 설정하면, 설정한 시간만큼 기다리다가 작업 포기 가능 

## 커밋
- 블로킹을 해소할 수 있는 방법
	- 블로킹 : 선행 트랜잭션이 설정한 Lock 때문에 후행 트랜잭션이 작업을 진행하지 못하고 멈춰 있는 상태 
### 비동기식 커밋과 배치 커밋
- 불필요한 잦은 커밋은,
	- 서버 프로세스가 LGWR에게 로그 버퍼를 비우도록 요청하고
    - 동기 방식으로 기다리는 횟수가 늘기 때문에 성능이 느려짐
- 잦은 커밋으로 성능이 느린 경우 활용할 수 있음 
- `WAIT` : LGWR가 로그버퍼를 파일에 기록했다는 완료 메세지를 받을 때까지 기다리는 동기식 커밋
  `NOWAIT` : LGWR의 완료 메시지를 기다리지 않고 바로 다음 트랜잭션을 진행하는 비동기식 커밋
- `IMMEDIATE` : 커밋 명령을 받을 때마다 LGWR가 로그 버퍼를 파일에 기록
  `BATCH` : 세션 내부에 트랜잭션 데이터를 일정량 버퍼링했다가 일괄 처리 

## 교착상태
- 두 트랜잭션이 각각 특정 리소스에 Lock을 설정한 상태에서 맞은편 트랜잭션이 Lock을 설정한 리소스에 또 Lock을 설정하려고 진행하는 상황
- 교착상태 발생 시,
	- 먼저 인지한 트랜잭션이 문장 수준 롤백 진행
    - 에러 메세지
    `0RA-00060: deadlock detected while waiting for resource` 
    - 이 메세지를 받은 트랜잭션은 커밋 도는 롤백을 결정
    	- 교착상태는 해소 되어도 블로킹 상태에 놓이기때문 

# 2. 트랜잭션 동시성 제어
**비관적 동시성 제어**
- Pessimistic Concurrency Control
- 사용자들이 같은 데이터를 동시에 수정할 것으로 가정
- 따라서 한 사용자가 데이터를 읽는 시점에 Lock을 걸고 조회 또는 갱신처리가 완료될 때까지 유지
- 잘못 사용하는 경우 동시성이 나빠질 수 있음

**낙관적 동시성 제어**
- Optimistic Concurrency Control
- 사용자들이 같은 데이터를 동시에 수정하지 않을 것으로 가정
- 따라서 데이터를 읽을 때 Lock을 설정하지 않음
- 읽는 시점에 Lock을 사용하지 않아도, 데이터를 수정하고자 하는 시점에 앞서 읽은 데이터가 변경되었는지 반드시 검사해야 함 

## ① 비관적 동시성 제어
```sql
select 적립포인트, 방문횟수, 최근방문일시, 구매실적 from 고객
where 고객번호=:cust_num for update;
```
	- 고객 레코드에 Lock을 설정하여 데이터가 잘못 갱신되는 문제 방지 
- 자칫 시스템 동시성을 심각하게 떨어뜨릴 우려가 있지만, 
`WAIT` 또는 `NOWAIT` 옵션을 함께 사용하면 무한정 기다리지 않아도 됨
- 옵션을 사용하면 다른 트랜잭션에 의해 Lock이 걸렸을 때, Exception을 만남
	- `다른 사용자에 의해 변경 중이므로 다시 시도하십시오` 메세지 출력 
    - 트랜잭션을 바로 종료할 수 있으므로 오히려 동시성을 증가시키게 도미 

** skip locked
- lock이 걸린 레코드는 생략하고 다음 레코드를 계속 읽도록 구현 가능 
- 한 건씩 fetch하는 것은 성능이 좋지 않으니, array 처리하는 것이 좋음
```sql
select cust_id,rcpt_amt from cust_rcpt_Q
where yn_upd = 'Y' FOR UPDATE SKIP LOCKED;
```

## ② 낙관적 동시성 제어 
- UPDATE 전에 SELECT문을 수행함으로써 Lock에 대한 예외처리
	- 다른 트랜잭션이 설정한 Lock을 기다리지 않게 구현 가능
```sql
select 고객번호
from 고객
where 고객번호 = :cust_num
and 변경일시 = :mod_dt
for update nowait;
```

## ③ 동시성 제어 없는 낙관적 프로그래밍 
- 낙관적 동시성 제어
	- Lock이 유지되는 시간이 매우 짧아져 동시성을 높이는데 매우 유리
    - 하지만, 데이터를 변경했는지 검사하고 그에 따라 처리 방향성을 결정하는 것은 귀찮은 절차 
- 동시에 같은 정보를 갱신할 가능성이 있는데도 동시성 제어를 구현하지 않으면 문제 발생 가능 

## ④ 데이터 품질과 동시성 향상
**FOR UPDATE**
- FOR UPDATE 사용을 두려워하지 말고 사용하기 
	- 필요한 상황이면 정확하게 사용하고,
    - 코딩이 번거롭더라도 동시성이 나빠지지 않게 `WAIT` 또는 `NOWAIT` 옵션을 활용한 예외처리 필요 
- 다중 트랜잭션이 존재하는 데이터베이스 환경에서 공유 자원에 대한 액세스 직렬화는 필수
- JAVA 프로그래머라면, 멀티쓰레드 프로그래밍할 때 `synchronized` 키워드의 역할 상기 

**커밋**
- 불필요하게 Lock을 오래 유지하지 말고, 트랜잭션의 원자성을 보장하는 범위 내에서 가급적 빨리 커밋 
- 트랜잭션을 재생할 수 있는 경우라면 중간에 적당한 주기로 커밋하는 것도 좋은 방안 

**동시 사용**
- 낙관적,비관적 동시성 제어를 같이 사용하는 것도 방법
- 일단 낙관적 동시성 제어를 시도했다가, 다른 트랜잭션에 의해 데이터가 변경된 사실이 발견될 경우 롤백하고 다시 시도할 때 비관적 동시성 제어 사용 

**SQL 튜닝**
- 동시성을 향상하고자 할 때 SQL 튜닝은 기본
- 가장 효율적인 인덱스를 구성해주고, 데이터량에 맞는 조인 메소드를 선택
- Array Processing, One SQL 등으로 처리 성능이 빨라지면 Lock도 빨리 해제됨 

# 3. 채번 방식에 따른 INSERT 성능 비교
- 가장 중요하고 튜닝 요소가 많은 것은 INSERT
- 수행빈도가 가장 높기도 하지만, 채번 방식에 따른 성능 차이가 매우 크기 때문
- 신규 데이터를 입력하려면 PK 중복을 방지하기 위한 채번이 선행되어야 함
	- 채번 테이블
    - 시퀀스 오브젝트
    - MAX + 1 조회 

## ① 채번 테이블
> 각 테이블 식별자의 단일컬럼 일련번호 또는 구분 속성별 순번을 채번하기 위해 별도 테이블을 관리하는 방식 

** 구분 속성 : PK가 복합컬럼으로 구성되어 있을 때, 순번 이외의 컬럼 

- 채번 레코드를 읽어서 1을 더한 값으로 변경하고, 그 값을 새로운 레코드를 입력하는데 사용
- 채번 레코드를 변경하는 과정에 자연스럽게 액세스 직렬화가 이뤄짐
	- 두 트랜잭션이 중복 값을 채번할 가능성을 원천적으로 방지 

**장점**
- 범용성이 좋음
- INSERT 과정에 중복 레코드 발생에 대비한 예외 처리에 크게 신경쓰지 않아도 됨
	- 채번 함수만 잘 정의하면 편리하게 사용 가능
- INSERT 과정에 결번을 방지할 수 있음
- PK가 복합컬럼일 때도 사용 가능 

**단점**
- 다른 채번 방식에 비해 성능이 좋지 않음
	- 채번 레코드를 변경하기 위한 로우 Lock 경합 때문
	- 로우 Lock은 대상 테이블에 INSERT를 마치고 커밋 또는 롤백할 때까지 지속 
- 동시 INSERT가 아주 많으면 채번 레코드뿐만 아니라 채번 테이블 블록 자체에도 경합이 발생
	- 즉, 서로 다른 레코드를 변경하는 프로세스끼리도 경합할 수 있다는 뜻
- 구분 속성별 순번을 채번하는 경우에는 Lock 경합이 줄어들지만, 
	- 구분 속성 레코드 수가 소수일 때만 이 방식을 사용하기 때문에
    - Lock 경합이 발생할 가능성은 여전히 높음 
    - 따라서 동시 INSERT가 아주 많은 테이블에는 사실상 사용하기 어려운 방식 

cf ) 자율 트랜잭션
- PL/SQL 의 자율 트랜잭션 기능
- 메인 트랜잭션에 영향을 주지 않고 서브 트랜잭션에서 일부 자원만 Lock 해제 가능
- `pragma autonomous_transaction` 
- 내부에서 커밋을 수행해도 메인 트랜잭션은 커밋하지 않은 상태로 남음
- 메인 트랜잭션 INSERT 문에서 채번 함수를 호출하고 최종적으로 커밋하기 전까지 다른 작업을 수행하더라도,
	- 채번 테이블 로우 Lock은 이미 해제한 상태
    - 다른 트랜잭션을 블록킹하지 않음
```sql
create or replace function seq_nextval(l_gubun number) return number
as
	pragma autonomous_transaction;
    l_new_seq seq_tab.seq%type;
begin
	update seq_tab
    set seq = seq +1
    where gubun = l_gubun;
    
    select seq into l_new_seq
    from seq_tab
    where gubun = l_gubun;
    
    commit;
    
    return l_new_seq;
end;
```
## ② 시퀀스 오브젝트
**장점**
- 가장 큰 장점은 성능이 빠르다는 것
- INSERT 과정에 중복 레코드 발생에 대비한 예외처리에 크게 신경쓰지 않아도 됨
- 테이블별로 시퀀스 오브젝트를 생성하고 관리하는 부담은 있지만, 개발팀 입장에서는 사용하기 편리 
- <u>시퀀스 채번 과정에 발생하는 Lock</u> 으로 인해 성능 이슈가 존재하기도 함
	- 시퀀스 오브젝트는 오라클 내부에서 관리하는 채번 테이블 
    - SYS.SEQ$ 테이블 , DBA_SEQUENCES 뷰를 통해 조회 가능 
	- 즉, 시퀀스 오브젝트도 결국 테이블이므로 값을 읽고 변경하는 과정에 Lock 메커니즘 작동 
- 캐시 사이즈를 적절히 설정하면 가장 빠른 성능을 제공
- 시퀀스에는 자율 트랜잭션 기능도 기본적으로 구현되어 있음 
### 시퀀스 Lock
**(1) 로우 캐시 Lock**
- 딕셔너리 정보를 매번 디스크에서 읽고 쓰면 성능이 매우 느리므로 로우 캐시 사용
- 로우 캐시는 SGA의 구성 요소이므로, 정보를 읽고 쓸 때 액세스 직렬화 필요 
- 이 때 사용하는 Lock이 <u>로우 캐시 Lock</u>
- 로우 캐시를 사용하는 대표적인 오브젝트가 시퀀스이므로, 로우 캐시 Lock 경합이 나타날 수 있음 
	- 즉, 많은 사용자가 동시에 nextval을 호출하면 로우 캐시 Lock 경합 발생
- Lock 경합을 줄이기 위해 기본적으로 **CACHE 옵션** 사용
	- 기본값은 20
    - Lock 경합을 줄이고 싶다면 이 값을 크게 사용 
    - 채반 빈도가 낮아 굳이 캐시를 사용하고 싶지 않다면 NOCACHE 옵션 지정 

**(2) 시퀀스 캐시 Lock**
- 시퀀스 캐시도 공유 캐시에 위치하므로, 시퀀스 캐시에서 값을 얻을 때도 액세스 직렬화 필요
- 이를 <u>SQ Lock</u>이라고 부름 

**(3) SV Lock**
- 시퀀스 캐시는 한 인스턴스 내에서 공유
	- nextval을 호출하는 순서대로 값을 제공
    - 인스턴스 내에서는 번호 순서를 보장
- 데이터베이스 하나에 인스턴스가 여러 개인 RAC 환경에서는 인스턴스마다 시퀀스 캐시를 따로 가짐 
	- 즉, 인스턴스 간에는 번호 순서를 기본적으로 보장하지 않음 
- 어떤 인스턴스에서 nextval을 호출하더라도 순서대로 일련번호를 제공해야 한다면 **ORDER 옵션** 사용
	- 시퀀스 캐시 하나를 모든 RAC 노드가 공유 가능 
- 자원을 공유할 때는 항상 Lock 메커니즘이 필요
	- RAC 환경에서 ORDER 옵션을 사용하면 **SV Lock을 통해 시퀀스 캐시에 대한 액세스 직렬화**
    - 네트워크를 통해 시퀀스 캐시를 서로 주고 받으면서 공유하므로 성능이 나빠질 수 있음
    - 단, RAC에서 ORDER 옵션이 필요하다면 시퀀스가 가장 최적의 솔루션 

**단점**
- 기본적으로 PK가 단일컬럼일 때만 사용 가능
- PK가 복합컬럼일 때도 사용할 수는 있지만, 최소성 요건을 위배하게 됨 
	- 최소성 요건 : 각 레코드를 유일하게 식별하는 최소 컬럼으로 PK를 구성해야 함
    - PK가 복합컬럼인데 동시 트랜잭션이 높아 시퀀스가 꼭 필요하다면, <u>순환 옵션을 가진 시퀀스 </u>활용을 고려 가능 
    	- 하루에 도달할 수 없는 값으로 최대값을 설정하고, 그 값에 도달하면 1부터 다시 시작하도록 순환옵션 설정
        - 값이 무한정 커지지 않게 함으로써 순번 컬럼 길이를 최소화하기 위함
        - 일반적으로 권장할 솔루션은 아니지만, 채번 성능이 문제가 될 때 고려해볼 수 있음 
 - 신규 데이터를 입력하는 과정에 결번이 생길 수 이음
 	- 시퀀스 채번 이후에 트랜잭션을 롤백하는 경우
    	- 시퀀스를 Shared Pool에 Keep 하면 막을 수 있음
        - 업무적으로 반드시 필요한 경우는 많지 않음 
      ```sql
        SQL > EXEC SYS.DBMS_SHARED_POOL.KEEP('SCOTT.MY_SEQ','Q');
      ```
    - CACHE 옵션을 설정한 시퀀스가 캐시에서 밀려나는 경우 
    	- 캐시에서 밀려나거나 인스턴스를 재기동하는 순간, 캐시되어 있던 번호는 모두 사라짐
        - 디스크에서 다시 읽을 때 다음 번호부터 읽음
    
### 12c 시퀀스 신기능
**(1) 컬럼 기본값으로 시퀀스 지정**
- 컬럼 기본값으로 시퀀스를 지정할 수 있음
- 기본값을 지정한 컬럼에 값을 입력할 수도 있지만, 입력하지 않을 수도 있음
- 값을 입력하지 않으면, 오라클이 대신 시퀀스 nextval을 호출해서 값을 입력
```sql
create sequence my_seq;

create table_t(
	c1 number default my_seq.nextval not null
   ,c2 varchar2(5));
   
insert into t (c1,c2) values (my_seq.nextval,'x');
insert into t (c2) values('x');
```

**(2) IDENTITY 컬럼**
- 특정 컬럼을 IDENTITY 컬럼으로 지정 가능
- 기본적으로는 시스템이 값을 입력
- 사용자가 직접 값을 입력할 수도 있으려면, `GENERATED BY DEFAULT` 옵션 지정
```sql
create table t (c1 number generated always as identity, c2 varchar2(5));

insert into t (c2) values ('X');
insert into t (c1,c2) values (default, 'X');

create table t (c1 number generated by default as identity, c2 varchar2(5));
```

**(3) 세션 시퀀스**
- 글로벌 시퀀스 : 여러 세션이 공유할 수 있는 시스템 레벨 시퀀스
```sql
create sequence g_seq GLOBAL;
```
- 세션 시퀀스 : 여러 세션이 공유할 수 없는 세션 레벨 시퀀스 
	- 세션이 종료되면 초기화됨
    - Lock 메커니즘이 불필요하여 글로벌 시퀀스보다 성느이 좋음 
    - 하지만, 모든 글로벌 시퀀스를 대체할 수는 없으므로 용도에 맞게 선택 필요
```sql
create sequence s_seq SESSION;
```
	
### 시퀀스보다 좋은 솔루션
- 한 개 이상의 구분 속성과 함께 뒤쪽에는 순번 대신 입력일시를 두는 방식으로 PK 구조를 설계
	- 채번 또는 INSERT 과정에 생기는 Lock 이슈 거의 해소 가능 
    - 채번 과정을 생략하고 SYSDATE 또는 SYSTIMESTAMP 함수만 호출하면 됨 
- 값의 종류 개수가 많으면 입력일시에 DATE 타입도 사용 가능
	- 값의 종류 개수가 적으면 TIMESTAMP 타입을 선택해야 함 
- 적절한 타입을 선택하면, 중복 가능성이 매우 희박하지만 예외처리는 필요 


## ③ MAX+1 조회
- 대상 테이블의 최종 일련번호를 조회하고, 거기에 1을 더해서 INSERT 하는 방식
```sql
insert into 상품거래(거래일련번호,계좌번호,거래일시,상품코드,거래가격,거래수량)
values ( (select max(거래일련번호) +1 from 상품거래)
		, :acnt_no, sysdate, :prod_cd, :trd_price, :trd_qty);
```

**장점**
- 시퀀스 또는 별도의 채번 테이블을 관리하는 부담이 없음
- 동시 트랜잭션에 의한 충돌이 많지 않으면, 성능이 매우 빠름
- PK가 복합컬럼인 경우에도 사용 가능 
	- 즉, 구분 속성별 순번을 채번할 때도 사용 가능 
    - 값의 수가 많아도 상관없고, 오히려 값의 수가 많을 수록 성능이 더 좋아짐
    - 입력 값 중복에 의한 로우 Lock 경합이 줄고 재실행 횟수도 줄기 때문 

**단점**
- 레코드 중복에 대비한 세밀한 예외처리 필요
- 다중 트랜잭션에 의한 동시 채번이 심하면 시퀀스보다 성능이 많이 나빠질 수 있음
	- 레코드 중복에 의한 로우 Lock 경합 때문 
    - 로우 Lock은 선행 트랜잭션이 커밋 또는 롤백할 때까지 지속 
    - 선행 트랜잭션이 롤백하지 않는 한, INSERT는 결국 실패해서 채번과 INSERT를 다시 실행함
	- PK가 복합컬럼이고 구분 속성별 값의 수가 많으면, 구분 속성 값별로 채번이 분산
    	- 동시 채번이 많아도 로우 Lock 경합 및 재실행 가능성은 현저히 줄어듬 
- MAX 값 조회에 최적화된 인덱스를 구성해 주지 않으면 기타 성능 이슈 발생 가능 

## 채번 방식 선택 기준 정리
1. 다중 트랜잭션에 의한 동시 채번이 많지 않으면, 세가지 방식 중 어느 것을 사용해도 크게 상관없음.
하지만, 채번 테이블이나 시퀀스 오브젝트 관리 부담을 고려한다면 가급적 MAX+1 방식을 선택하는 것이 좋음 
2. 다중 트랜잭션에 의한 동시 채번이 많고 PK가 단일컬럼 일련번호라면, 시퀀스 방식이 가장 좋음
3. 다중 트랜잭션에 의한 동시 채번이 많고 PK 구분 속성에 값 종류 개수가 많으면, 중복에 의한 로우 Lock 경합 및 재실행 가능성이 낮음. 그런 경우 시퀀스보다 MAX+1 방식이 구조적으로 좋음.
4. 다중 트랜잭션에 의한 동시 채번이 많고 PK 구분 속성에 값 종류 개수가 적으면, MAX+1 방식은 성능에 문제가 생길 수 있음. 그럴 때 순환 옵션을 가진 시퀀스 오브젝트 활용을 고려할 수 있음. 

## 인덱스 블록 경합
- INSERT 성능이 너무 빨라도 문제
- 채번 과정을 생략하는 순간부터 인덱스 블록 경합이 나타나기 시작
	- 채번 테이블 로우 Lock이나 시퀀스 Lock이 있으면 잘 안 나타남
    - MAX+1 방식을 사용할 때도 자주 나타남
- Right Growing 인덱스에서 가장 흔히 볼 수 있음
	- 맨 우측 블록에만 데이터가 입력되는 인덱스
- 입력하는 값이 달라도 같은 블록을 갱신하려는 프로세스 간 버퍼 Lock 경합 발생 가능 
- 이는, 여러 프로세스에 의한 동시 INSERT가 많을 때 트랜잭션 성능을 떨어뜨리는 주범 
- 특히 RAC 환경에서 심각한 성능 저하를 일으킴
	- 여러 노드가 동시에 Current 블록 하나를 서로 주고 받으며 값을 입력하기 때문 
- 구분 속성을 앞에 두면 Right Growing 인덱스는 아니지만, 동시성이 매우 높으면 경합 발생 가능
	- 구분 속성의 값 종류 개수가 적을 수록 경합도 심함

**해소 방안**
- 가장 일반적인 방법은 인덱스를 해시 파티셔닝
	- 값이 순차적으로 증가하더라도 해시 함수가 리턴한 값에 따라 서로 다른 파티션에 입력
    - 경합을 줄일 수 있음
- 인덱스를 리버스 키 인덱스로 전환하는 방법도 고려 가능 